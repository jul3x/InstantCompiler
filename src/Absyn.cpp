//C++ Abstract Syntax Implementation generated by the BNF Converter.
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include "Absyn.h"

/********************   Prog    ********************/
Prog::Prog(ListStmt *p1)
{
    liststmt_ = p1;
}

Prog::Prog(const Prog &other)
{
    liststmt_ = other.liststmt_->clone();
}

Prog &Prog::operator=(const Prog &other)
{
    Prog tmp(other);
    swap(tmp);
    return *this;
}

void Prog::swap(Prog &other)
{
    std::swap(liststmt_, other.liststmt_);
}

Prog::~Prog()
{
    delete (liststmt_);
}

std::pair<int, bool> Prog::accept(Visitor *v)
{
    v->visitProg(this);
    return std::make_pair(0, false);
}

Prog *Prog::clone() const
{
    return new Prog(*this);
}

/********************   SAss    ********************/
SAss::SAss(Ident p1, Exp *p2)
{
    ident_ = p1;
    exp_ = p2;
}

SAss::SAss(const SAss &other)
{
    ident_ = other.ident_;
    exp_ = other.exp_->clone();
}

SAss &SAss::operator=(const SAss &other)
{
    SAss tmp(other);
    swap(tmp);
    return *this;
}

void SAss::swap(SAss &other)
{
    std::swap(ident_, other.ident_);
    std::swap(exp_, other.exp_);
}

SAss::~SAss()
{
    delete (exp_);
}

std::pair<int, bool> SAss::accept(Visitor *v)
{
    return v->visitSAss(this);
}

SAss *SAss::clone() const
{
    return new SAss(*this);
}

/********************   SExp    ********************/
SExp::SExp(Exp *p1)
{
    exp_ = p1;
}

SExp::SExp(const SExp &other)
{
    exp_ = other.exp_->clone();
}

SExp &SExp::operator=(const SExp &other)
{
    SExp tmp(other);
    swap(tmp);
    return *this;
}

void SExp::swap(SExp &other)
{
    std::swap(exp_, other.exp_);
}

SExp::~SExp()
{
    delete (exp_);
}

std::pair<int, bool> SExp::accept(Visitor *v)
{
    return v->visitSExp(this);
}

SExp *SExp::clone() const
{
    return new SExp(*this);
}

/********************   ExpAdd    ********************/
ExpAdd::ExpAdd(Exp *p1, Exp *p2)
{
    exp_1 = p1;
    exp_2 = p2;
}

ExpAdd::ExpAdd(const ExpAdd &other)
{
    exp_1 = other.exp_1->clone();
    exp_2 = other.exp_2->clone();
}

ExpAdd &ExpAdd::operator=(const ExpAdd &other)
{
    ExpAdd tmp(other);
    swap(tmp);
    return *this;
}

void ExpAdd::swap(ExpAdd &other)
{
    std::swap(exp_1, other.exp_1);
    std::swap(exp_2, other.exp_2);
}

ExpAdd::~ExpAdd()
{
    delete (exp_1);
    delete (exp_2);
}

std::pair<int, bool> ExpAdd::accept(Visitor *v)
{
    return v->visitExpAdd(this);
}

ExpAdd *ExpAdd::clone() const
{
    return new ExpAdd(*this);
}

/********************   ExpSub    ********************/
ExpSub::ExpSub(Exp *p1, Exp *p2)
{
    exp_1 = p1;
    exp_2 = p2;
}

ExpSub::ExpSub(const ExpSub &other)
{
    exp_1 = other.exp_1->clone();
    exp_2 = other.exp_2->clone();
}

ExpSub &ExpSub::operator=(const ExpSub &other)
{
    ExpSub tmp(other);
    swap(tmp);
    return *this;
}

void ExpSub::swap(ExpSub &other)
{
    std::swap(exp_1, other.exp_1);
    std::swap(exp_2, other.exp_2);
}

ExpSub::~ExpSub()
{
    delete (exp_1);
    delete (exp_2);
}

std::pair<int, bool> ExpSub::accept(Visitor *v)
{
    return v->visitExpSub(this);
}

ExpSub *ExpSub::clone() const
{
    return new ExpSub(*this);
}

/********************   ExpMul    ********************/
ExpMul::ExpMul(Exp *p1, Exp *p2)
{
    exp_1 = p1;
    exp_2 = p2;
}

ExpMul::ExpMul(const ExpMul &other)
{
    exp_1 = other.exp_1->clone();
    exp_2 = other.exp_2->clone();
}

ExpMul &ExpMul::operator=(const ExpMul &other)
{
    ExpMul tmp(other);
    swap(tmp);
    return *this;
}

void ExpMul::swap(ExpMul &other)
{
    std::swap(exp_1, other.exp_1);
    std::swap(exp_2, other.exp_2);
}

ExpMul::~ExpMul()
{
    delete (exp_1);
    delete (exp_2);
}

std::pair<int, bool> ExpMul::accept(Visitor *v)
{
    return v->visitExpMul(this);
}

ExpMul *ExpMul::clone() const
{
    return new ExpMul(*this);
}

/********************   ExpDiv    ********************/
ExpDiv::ExpDiv(Exp *p1, Exp *p2)
{
    exp_1 = p1;
    exp_2 = p2;
}

ExpDiv::ExpDiv(const ExpDiv &other)
{
    exp_1 = other.exp_1->clone();
    exp_2 = other.exp_2->clone();
}

ExpDiv &ExpDiv::operator=(const ExpDiv &other)
{
    ExpDiv tmp(other);
    swap(tmp);
    return *this;
}

void ExpDiv::swap(ExpDiv &other)
{
    std::swap(exp_1, other.exp_1);
    std::swap(exp_2, other.exp_2);
}

ExpDiv::~ExpDiv()
{
    delete (exp_1);
    delete (exp_2);
}

std::pair<int, bool> ExpDiv::accept(Visitor *v)
{
    return v->visitExpDiv(this);
}

ExpDiv *ExpDiv::clone() const
{
    return new ExpDiv(*this);
}

/********************   ExpLit    ********************/
ExpLit::ExpLit(Integer p1)
{
    integer_ = p1;
}

ExpLit::ExpLit(const ExpLit &other)
{
    integer_ = other.integer_;
}

ExpLit &ExpLit::operator=(const ExpLit &other)
{
    ExpLit tmp(other);
    swap(tmp);
    return *this;
}

void ExpLit::swap(ExpLit &other)
{
    std::swap(integer_, other.integer_);
}

ExpLit::~ExpLit()
{
}

std::pair<int, bool> ExpLit::accept(Visitor *v)
{
    return v->visitExpLit(this);
}

ExpLit *ExpLit::clone() const
{
    return new ExpLit(*this);
}

/********************   ExpVar    ********************/
ExpVar::ExpVar(Ident p1)
{
    ident_ = p1;
}

ExpVar::ExpVar(const ExpVar &other)
{
    ident_ = other.ident_;
}

ExpVar &ExpVar::operator=(const ExpVar &other)
{
    ExpVar tmp(other);
    swap(tmp);
    return *this;
}

void ExpVar::swap(ExpVar &other)
{
    std::swap(ident_, other.ident_);
}

ExpVar::~ExpVar()
{
}

std::pair<int, bool> ExpVar::accept(Visitor *v)
{
    return v->visitExpVar(this);
}

ExpVar *ExpVar::clone() const
{
    return new ExpVar(*this);
}

/********************   ListStmt    ********************/

std::pair<int, bool> ListStmt::accept(Visitor *v)
{
    v->visitListStmt(this);

    return std::make_pair(0, false);
}

ListStmt *ListStmt::clone() const
{
    return new ListStmt(*this);
}
