#ifndef ABSYN_HEADER
#define ABSYN_HEADER

#include <string>
#include <vector>

//C++ Abstract Syntax Interface generated by the BNF Converter.

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;

/********************   Forward Declarations    ********************/

class Program;
class Stmt;
class Exp;
class Prog;
class SAss;
class SExp;
class ExpAdd;
class ExpSub;
class ExpMul;
class ExpDiv;
class ExpLit;
class ExpVar;
class ListStmt;

/*
 * Visitor Interfaces
 * Return value pair<int, bool> determines if return value is a number or register number (true if register number)
 * Used in either llvm and jvm
 */

class Visitor
{
public:
    virtual ~Visitor() {}
    virtual void visitProgram(Program *p) = 0;
    virtual void visitStmt(Stmt *p) = 0;
    virtual void visitExp(Exp *p) = 0;
    virtual void visitProg(Prog *p) = 0;
    virtual std::pair<int, bool> visitSAss(SAss *p) = 0;
    virtual std::pair<int, bool> visitSExp(SExp *p) = 0;
    virtual std::pair<int, bool> visitExpAdd(ExpAdd *p) = 0;
    virtual std::pair<int, bool> visitExpSub(ExpSub *p) = 0;
    virtual std::pair<int, bool> visitExpMul(ExpMul *p) = 0;
    virtual std::pair<int, bool> visitExpDiv(ExpDiv *p) = 0;
    virtual std::pair<int, bool> visitExpLit(ExpLit *p) = 0;
    virtual std::pair<int, bool> visitExpVar(ExpVar *p) = 0;
    virtual void visitListStmt(ListStmt *p) = 0;

    virtual std::pair<int, bool> visitInteger(Integer x) = 0;
    virtual std::pair<int, bool> visitChar(Char x) = 0;
    virtual std::pair<int, bool> visitDouble(Double x) = 0;
    virtual std::pair<int, bool> visitString(String x) = 0;
    virtual std::pair<int, bool> visitIdent(Ident x) = 0;
};

class Visitable
{
public:
    Visitable() { difficulty_ = 0; }
    virtual ~Visitable() {}
    virtual std::pair<int, bool> accept(Visitor *v) = 0;

    unsigned int difficulty_;
};

/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
    virtual Program *clone() const = 0;
};

class Stmt : public Visitable
{
public:
    virtual Stmt *clone() const = 0;
};

class Exp : public Visitable
{
public:
    virtual Exp *clone() const = 0;
};

class Prog : public Program
{
public:
    ListStmt *liststmt_;

    Prog(const Prog &);
    Prog &operator=(const Prog &);
    Prog(ListStmt *p1);
    ~Prog();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual Prog *clone() const;
    void swap(Prog &);
};

class SAss : public Stmt
{
public:
    Ident ident_;
    Exp *exp_;

    SAss(const SAss &);
    SAss &operator=(const SAss &);
    SAss(Ident p1, Exp *p2);
    ~SAss();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual SAss *clone() const;
    void swap(SAss &);
};

class SExp : public Stmt
{
public:
    Exp *exp_;

    SExp(const SExp &);
    SExp &operator=(const SExp &);
    SExp(Exp *p1);
    ~SExp();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual SExp *clone() const;
    void swap(SExp &);
};

class ExpAdd : public Exp
{
public:
    Exp *exp_1;
    Exp *exp_2;

    ExpAdd(const ExpAdd &);
    ExpAdd &operator=(const ExpAdd &);
    ExpAdd(Exp *p1, Exp *p2);
    ~ExpAdd();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual ExpAdd *clone() const;
    void swap(ExpAdd &);
};

class ExpSub : public Exp
{
public:
    Exp *exp_1;
    Exp *exp_2;

    ExpSub(const ExpSub &);
    ExpSub &operator=(const ExpSub &);
    ExpSub(Exp *p1, Exp *p2);
    ~ExpSub();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual ExpSub *clone() const;
    void swap(ExpSub &);
};

class ExpMul : public Exp
{
public:
    Exp *exp_1;
    Exp *exp_2;

    ExpMul(const ExpMul &);
    ExpMul &operator=(const ExpMul &);
    ExpMul(Exp *p1, Exp *p2);
    ~ExpMul();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual ExpMul *clone() const;
    void swap(ExpMul &);
};

class ExpDiv : public Exp
{
public:
    Exp *exp_1;
    Exp *exp_2;

    ExpDiv(const ExpDiv &);
    ExpDiv &operator=(const ExpDiv &);
    ExpDiv(Exp *p1, Exp *p2);
    ~ExpDiv();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual ExpDiv *clone() const;
    void swap(ExpDiv &);
};

class ExpLit : public Exp
{
public:
    Integer integer_;

    ExpLit(const ExpLit &);
    ExpLit &operator=(const ExpLit &);
    ExpLit(Integer p1);
    ~ExpLit();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual ExpLit *clone() const;
    void swap(ExpLit &);
};

class ExpVar : public Exp
{
public:
    Ident ident_;

    ExpVar(const ExpVar &);
    ExpVar &operator=(const ExpVar &);
    ExpVar(Ident p1);
    ~ExpVar();
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual ExpVar *clone() const;
    void swap(ExpVar &);
};

class ListStmt : public Visitable, public std::vector<Stmt *>
{
public:
    virtual std::pair<int, bool> accept(Visitor *v);
    virtual ListStmt *clone() const;
};

#endif
